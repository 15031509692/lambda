<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Lambda by palatable</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Lambda</h1>
        <p class="header">Functional patterns for Java</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/palatable/lambda/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/palatable/lambda/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/palatable/lambda">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/palatable">palatable</a></p>


      </header>
      <section>
        <h1>
<a id="λ" class="anchor" href="#%CE%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>λ</h1>

<p><a href="https://travis-ci.org/palatable/lambda"><img src="https://travis-ci.org/palatable/lambda.svg" alt="Build Status"></a>
<a href="http://search.maven.org/#search%7Cga%7C1%7Ccom.jnape.palatable.lambda"><img src="https://img.shields.io/maven-central/v/com.jnape.palatable/lambda.svg" alt="Lambda"></a></p>

<p>Functional patterns for Java 8</p>

<h4>
<a id="table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Table of Contents</h4>

<ul>
<li><a href="#background">Background</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#examples">Examples</a></li>
<li>
<a href="#adts">ADTs</a>

<ul>
<li>
<a href="#hlists">HLists</a>

<ul>
<li><a href="#tuples">Tuples</a></li>
</ul>
</li>
<li><a href="#hmaps">HMaps</a></li>
<li>
<a href="#coproducts">CoProducts</a>

<ul>
<li><a href="#either">Either</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lenses">Lenses</a></li>
<li>
<a href="#notes">Notes</a> </li>
<li><a href="#license">License</a></li>
</ul>

<h2>
<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="background">Background</a>
</h2>

<p>Lambda was born out of a desire to use some of the same canonical functions (e.g. <code>unfoldr</code>, <code>takeWhile</code>, <code>zipWith</code>) and functional patterns (e.g. <code>Functor</code> and friends) that are idiomatic in other languages and make them available for Java.</p>

<p>Some things a user of lambda most likely values:</p>

<ul>
<li>Lazy evaluation</li>
<li>Immutablility by design</li>
<li>Composition</li>
<li>Higher-level abstractions</li>
<li>Parametric polymorphism</li>
</ul>

<p>Generally, everything that lambda produces is lazily-evaluated (except for terminal operations like <code>reduce</code>), immutable (except for <code>Iterator</code>s, since it's effectively impossible), composable (even between different arities, where possible), foundational (maximally contravariant), and parametrically type-checked (even where this adds unnecessary constraints due to a lack of higher-kinded types).</p>

<p>Although the library is currently (very) small, these values should always be the driving forces behind future growth.</p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="installation">Installation</a>
</h2>

<p>Add the following dependency to your:</p>

<p><code>pom.xml</code> (<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Maven</a>):</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;com.jnape.palatable&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;lambda&lt;/<span class="pl-ent">artifactId</span>&gt;
    &lt;<span class="pl-ent">version</span>&gt;1.5.3&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre></div>

<p><code>build.gradle</code> (<a href="https://docs.gradle.org/current/userguide/dependency_management.html">Gradle</a>):</p>

<div class="highlight highlight-source-groovy-gradle"><pre>compile <span class="pl-c1">group</span>: <span class="pl-s"><span class="pl-pds">'</span>com.jnape.palatable<span class="pl-pds">'</span></span>, <span class="pl-c1">name</span>: <span class="pl-s"><span class="pl-pds">'</span>lambda<span class="pl-pds">'</span></span>, <span class="pl-c1">version</span>: <span class="pl-s"><span class="pl-pds">'</span>1.5.3<span class="pl-pds">'</span></span></pre></div>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="examples">Examples</a>
</h2>

<p>First, the obligatory <code>map</code>/<code>filter</code>/<code>reduce</code> example:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Integer</span> sumOfEvenIncrements <span class="pl-k">=</span>
          reduceLeft((x, y) <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> y,
              filter(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>,
                  map(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>, asList(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>))));
<span class="pl-c">//-&gt; 12</span></pre></div>

<p>Every function in lambda is <a href="https://www.wikiwand.com/en/Currying">curried</a>, so we could have also done this:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Fn1&lt;<span class="pl-k">Iterable&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-smi">Integer</span>&gt;</span> sumOfEvenIncrementsFn <span class="pl-k">=</span>
          map((<span class="pl-smi">Integer</span> x) <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>)
          .then(filter(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>))
          .then(reduceLeft((x, y) <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> y));

<span class="pl-smi">Integer</span> sumOfEvenIncrements <span class="pl-k">=</span> sumOfEvenIncrementsFn<span class="pl-k">.</span>apply(asList(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>));
<span class="pl-c">//-&gt; 12</span></pre></div>

<p>How about the positive squares below 100:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Iterable&lt;<span class="pl-smi">Integer</span>&gt;</span> positiveSquaresBelow100 <span class="pl-k">=</span>
          takeWhile(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">&lt;</span> <span class="pl-c1">100</span>, map(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">*</span> x, iterate(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)));
<span class="pl-c">//-&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></pre></div>

<p>We could have also used <code>unfoldr</code>:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Iterable&lt;<span class="pl-smi">Integer</span>&gt;</span> positiveSquaresBelow100 <span class="pl-k">=</span> unfoldr(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> {
              <span class="pl-k">int</span> square <span class="pl-k">=</span> x <span class="pl-k">*</span> x;
              <span class="pl-k">return</span> square <span class="pl-k">&lt;</span> <span class="pl-c1">100</span> <span class="pl-k">?</span> <span class="pl-smi">Optional</span><span class="pl-k">.</span>of(tuple(square, x <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">:</span> <span class="pl-smi">Optional</span><span class="pl-k">.</span>empty();
          }, <span class="pl-c1">1</span>);
<span class="pl-c">//-&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></pre></div>

<p>What if we want the cross product of a domain and codomain:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Iterable&lt;<span class="pl-k">Tuple2&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">String</span>&gt;</span>&gt;</span> crossProduct <span class="pl-k">=</span>
          take(<span class="pl-c1">10</span>, cartesianProduct(asList(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>), asList(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)));
<span class="pl-c">//-&gt; (1,"a"), (1,"b"), (1,"c"), (2,"a"), (2,"b"), (2,"c"), (3,"a"), (3,"b"), (3,"c")</span></pre></div>

<p>Let's compose two functions:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Fn1&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> add <span class="pl-k">=</span> x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>;
<span class="pl-k">Fn1&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> subtract <span class="pl-k">=</span> x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">-</span><span class="pl-c1">1</span>;

<span class="pl-k">Fn1&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> noOp <span class="pl-k">=</span> add<span class="pl-k">.</span>then(subtract);
<span class="pl-c">// same as</span>
<span class="pl-k">Fn1&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> alsoNoOp <span class="pl-k">=</span> subtract<span class="pl-k">.</span>compose(add);</pre></div>

<p>And partially apply some:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Fn2&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> add <span class="pl-k">=</span> (x, y) <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> y;

<span class="pl-k">Fn1&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> add1 <span class="pl-k">=</span> add<span class="pl-k">.</span>apply(<span class="pl-c1">1</span>);
add1<span class="pl-k">.</span>apply(<span class="pl-c1">2</span>);
<span class="pl-c">//-&gt; 3</span></pre></div>

<p>And have fun with 3s:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Iterable&lt;<span class="pl-k">Iterable&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> multiplesOf3InGroupsOf3 <span class="pl-k">=</span>
          take(<span class="pl-c1">10</span>, inGroupsOf(<span class="pl-c1">3</span>, unfoldr(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-smi">Optional</span><span class="pl-k">.</span>of(tuple(x <span class="pl-k">*</span> <span class="pl-c1">3</span>, x <span class="pl-k">+</span> <span class="pl-c1">1</span>)), <span class="pl-c1">1</span>)));
<span class="pl-c">//-&gt; [[3, 6, 9], [12, 15, 18], [21, 24, 27]]</span></pre></div>

<p>Check out the <a href="https://github.com/palatable/lambda/tree/master/src/test/java/com/jnape/palatable/lambda/functions/builtin">tests</a> or <a href="http://palatable.github.io/lambda/javadoc/">javadoc</a> for more examples.</p>

<h2>
<a id="adts" class="anchor" href="#adts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="adts">ADTs</a>
</h2>

<p>In addition to the functions above, lambda also supports a few first-class <a href="https://www.wikiwand.com/en/Algebraic_data_type">algebraic data types</a>.</p>

<h3>
<a id="heterogeneous-lists-hlists" class="anchor" href="#heterogeneous-lists-hlists" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="hlists">Heterogeneous Lists (HLists)</a>
</h3>

<p>HLists are type-safe heterogeneous lists, meaning they can store elements of different types in the same list while facilitating certain type-safe interactions.</p>

<p>The following illustrates how the linear expansion of the recursive type signature for <code>HList</code> prevents ill-typed expressions:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">HCons&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">HCons&lt;<span class="pl-smi">String</span>, <span class="pl-smi">HNil</span>&gt;</span>&gt;</span> hList <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>cons(<span class="pl-c1">1</span>, <span class="pl-smi">HList</span><span class="pl-k">.</span>cons(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-smi">HList</span><span class="pl-k">.</span>nil()));

<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(hList<span class="pl-k">.</span>head()); <span class="pl-c">// prints 1</span>
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(hList<span class="pl-k">.</span>tail()<span class="pl-k">.</span>head()); <span class="pl-c">// prints "foo"</span>

<span class="pl-smi">HNil</span> nil <span class="pl-k">=</span> hList<span class="pl-k">.</span>tail()<span class="pl-k">.</span>tail();
<span class="pl-c">//nil.head() won't type-check</span></pre></div>

<h4>
<a id="tuples" class="anchor" href="#tuples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="tuples">Tuples</a>
</h4>

<p>One of the primary downsides to using <code>HList</code>s in Java is how quickly the type signature grows.</p>

<p>To address this, tuples in lambda are specializations of <code>HList</code>s up to 5 elements deep, with added support for index-based accessor methods.</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">HNil</span> nil <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>nil();
<span class="pl-k">SingletonHList&lt;<span class="pl-smi">Integer</span>&gt;</span> singleton <span class="pl-k">=</span> nil<span class="pl-k">.</span>cons(<span class="pl-c1">5</span>);
<span class="pl-k">Tuple2&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple2 <span class="pl-k">=</span> singleton<span class="pl-k">.</span>cons(<span class="pl-c1">4</span>);
<span class="pl-k">Tuple3&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple3 <span class="pl-k">=</span> tuple2<span class="pl-k">.</span>cons(<span class="pl-c1">3</span>);
<span class="pl-k">Tuple4&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple4 <span class="pl-k">=</span> tuple3<span class="pl-k">.</span>cons(<span class="pl-c1">2</span>);
<span class="pl-k">Tuple5&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple5 <span class="pl-k">=</span> tuple4<span class="pl-k">.</span>cons(<span class="pl-c1">1</span>);

<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(tuple2<span class="pl-k">.</span>_1()); <span class="pl-c">// prints 4</span>
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(tuple5<span class="pl-k">.</span>_5()); <span class="pl-c">// prints 5</span></pre></div>

<p>Additionally, <code>HList</code> provides convenience static factory methods for directly constructing lists of up to 5 elements:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">SingletonHList&lt;<span class="pl-smi">Integer</span>&gt;</span> singleton <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>singletonHList(<span class="pl-c1">1</span>);
<span class="pl-k">Tuple2&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple2 <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>tuple(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>);
<span class="pl-k">Tuple3&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple3 <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>tuple(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>);
<span class="pl-k">Tuple4&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple4 <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>tuple(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>);
<span class="pl-k">Tuple5&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> tuple5 <span class="pl-k">=</span> <span class="pl-smi">HList</span><span class="pl-k">.</span>tuple(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>);</pre></div>

<p><code>Index</code> can be used for type-safe retrieval and updating of elements at specific indexes:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">HCons&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">HCons&lt;<span class="pl-smi">String</span>, <span class="pl-k">HCons&lt;<span class="pl-smi">Character</span>, <span class="pl-smi">HNil</span>&gt;</span>&gt;</span>&gt;</span> hList <span class="pl-k">=</span> cons(<span class="pl-c1">1</span>, cons(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>, cons(<span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>, nil())));
<span class="pl-k">HCons&lt;<span class="pl-smi">Integer</span>, <span class="pl-k">Tuple2&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Character</span>&gt;</span>&gt;</span> tuple <span class="pl-k">=</span> tuple(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>);
<span class="pl-k">Tuple5&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">String</span>, <span class="pl-smi">Character</span>, <span class="pl-smi">Double</span>, <span class="pl-smi">Boolean</span>&gt;</span> longerHList <span class="pl-k">=</span> tuple(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>, <span class="pl-c1">4.0d</span>, <span class="pl-c1">false</span>);

<span class="pl-k">Index&lt;<span class="pl-smi">Character</span>, <span class="pl-k">HCons&lt;<span class="pl-smi">Integer</span>, ? extends <span class="pl-k">HCons&lt;<span class="pl-smi">String</span>, ? extends <span class="pl-k">HCons&lt;<span class="pl-smi">Character</span>, ?&gt;</span>&gt;</span>&gt;</span>&gt;</span> characterIndex <span class="pl-k">=</span>
        <span class="pl-smi">Index</span><span class="pl-k">.</span><span class="pl-k">&lt;</span><span class="pl-smi">Character</span><span class="pl-k">&gt;</span>index()<span class="pl-c1">.</span><span class="pl-k">&lt;</span><span class="pl-smi">String</span><span class="pl-k">&gt;</span>after()<span class="pl-k">.</span>after();

characterIndex<span class="pl-k">.</span>get(hList); <span class="pl-c">// '3'</span>
characterIndex<span class="pl-k">.</span>get(tuple); <span class="pl-c">// '3'</span>
characterIndex<span class="pl-k">.</span>get(longerHList); <span class="pl-c">// '3'</span>

characterIndex<span class="pl-k">.</span>set(<span class="pl-s"><span class="pl-pds">'</span>4<span class="pl-pds">'</span></span>, hList); <span class="pl-c">// HList{ 1 :: "2" :: '4' }</span></pre></div>

<p>Finally, all <code>Tuple*</code> classes are instances of both <code>Functor</code> and <code>Bifunctor</code>:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Tuple2&lt;<span class="pl-smi">Integer</span>, <span class="pl-smi">String</span>&gt;</span> mappedTuple2 <span class="pl-k">=</span> tuple(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)<span class="pl-k">.</span>biMap(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>, <span class="pl-smi">Object</span><span class="pl-k">::</span>toString);

<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(mappedTuple2<span class="pl-k">.</span>_1()); <span class="pl-c">// prints 2</span>
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(mappedTuple2<span class="pl-k">.</span>_2()); <span class="pl-c">// prints "2"</span>

<span class="pl-k">Tuple3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Boolean</span>, <span class="pl-smi">Integer</span>&gt;</span> mappedTuple3 <span class="pl-k">=</span> tuple(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">1</span>)<span class="pl-k">.</span>biMap(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-k">!</span>x, x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>);

<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(mappedTuple3<span class="pl-k">.</span>_1()); <span class="pl-c">// prints "foo"</span>
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(mappedTuple3<span class="pl-k">.</span>_2()); <span class="pl-c">// prints false</span>
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(mappedTuple3<span class="pl-k">.</span>_3()); <span class="pl-c">// prints 2</span></pre></div>

<h3>
<a id="heterogeneous-maps" class="anchor" href="#heterogeneous-maps" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="hmaps">Heterogeneous Maps</a>
</h3>

<p>HMaps are type-safe heterogeneous maps, meaning they can store mappings to different value types in the same map; however, whereas HLists encode value types in their type signatures, HMaps rely on the keys to encode the value type that they point to. </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">TypeSafeKey&lt;<span class="pl-smi">String</span>&gt;</span> stringKey <span class="pl-k">=</span> <span class="pl-smi">TypeSafeKey</span><span class="pl-k">.</span>typeSafeKey();
<span class="pl-k">TypeSafeKey&lt;<span class="pl-smi">Integer</span>&gt;</span> intKey <span class="pl-k">=</span> <span class="pl-smi">TypeSafeKey</span><span class="pl-k">.</span>typeSafeKey();
<span class="pl-smi">HMap</span> hmap <span class="pl-k">=</span> <span class="pl-smi">HMap</span><span class="pl-k">.</span>hMap(stringKey, <span class="pl-s"><span class="pl-pds">"</span>string value<span class="pl-pds">"</span></span>,
                      intKey, <span class="pl-c1">1</span>);

<span class="pl-k">Optional&lt;<span class="pl-smi">String</span>&gt;</span> stringValue <span class="pl-k">=</span> hmap<span class="pl-k">.</span>get(stringKey); <span class="pl-c">// Optional["string value"]</span>
<span class="pl-k">Optional&lt;<span class="pl-smi">Integer</span>&gt;</span> intValue <span class="pl-k">=</span> hmap<span class="pl-k">.</span>get(intKey); <span class="pl-c">// Optional[1]</span>
<span class="pl-k">Optional&lt;<span class="pl-smi">Integer</span>&gt;</span> anotherIntValue <span class="pl-k">=</span> hmap<span class="pl-k">.</span>get(anotherIntKey); <span class="pl-c">// Optional.empty</span></pre></div>

<h3>
<a id="coproducts" class="anchor" href="#coproducts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="coproducts">CoProducts</a>
</h3>

<p><code>CoProduct</code>s generalize unions of disparate types in a single consolidated type.   </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> string <span class="pl-k">=</span> <span class="pl-smi">CoProduct3</span><span class="pl-k">.</span>a(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>);
<span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> integer <span class="pl-k">=</span> <span class="pl-smi">CoProduct3</span><span class="pl-k">.</span>b(<span class="pl-c1">1</span>);
<span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> character <span class="pl-k">=</span> <span class="pl-smi">CoProduct3</span><span class="pl-k">.</span>c(<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>);</pre></div>

<p>Rather than supporting explicit value unwrapping, which would necessarily jeopardize type safety, <code>CoProduct</code>s support a <code>match</code> method that takes one function per possible value type and maps it to a final common result type:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> string <span class="pl-k">=</span> <span class="pl-smi">CoProduct3</span><span class="pl-k">.</span>a(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>);
<span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> integer <span class="pl-k">=</span> <span class="pl-smi">CoProduct3</span><span class="pl-k">.</span>b(<span class="pl-c1">1</span>);
<span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> character <span class="pl-k">=</span> <span class="pl-smi">CoProduct3</span><span class="pl-k">.</span>c(<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>);

<span class="pl-smi">Integer</span> result <span class="pl-k">=</span> string<span class="pl-k">.</span><span class="pl-k">&lt;</span><span class="pl-smi">Integer</span><span class="pl-k">&gt;</span>match(<span class="pl-smi">String</span><span class="pl-k">::</span>length, identity(), <span class="pl-smi">Character</span><span class="pl-k">::</span>charCount); <span class="pl-c">// 6</span></pre></div>

<p>Additionally, because a <code>CoProduct2&lt;A, B&gt;</code> guarantees a subset of a <code>CoProduct3&lt;A, B, C&gt;</code>, the <code>diverge</code> method exists between <code>CoProduct</code> types of single magnitude differences to make it easy to use a more convergent <code>CoProduct</code> where a more divergent <code>CoProduct</code> is expected:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">CoProduct2&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span> coProduct2 <span class="pl-k">=</span> <span class="pl-smi">CoProduct2</span><span class="pl-k">.</span>a(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>);
<span class="pl-k">CoProduct3&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Character</span>&gt;</span> coProduct3 <span class="pl-k">=</span> coProduct2<span class="pl-k">.</span>diverge(); <span class="pl-c">// still just the coProduct2 value, adapted to the coProduct3 shape</span></pre></div>

<p>There are <code>CoProduct</code> specializations for type unions of up to 5 different types: <code>CoProduct2</code> through <code>CoProduct5</code>, respectively.</p>

<h3>
<a id="either" class="anchor" href="#either" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="either">Either</a>
</h3>

<p><code>Either&lt;L, R&gt;</code> represents a specialized <code>CoProduct2&lt;L, R&gt;</code>, which resolve to one of two possible values: a left value wrapping an <code>L</code>, or a right value wrapping an <code>R</code> (typically an exceptional value or a successful value, respectively).</p>

<p>As with <code>CoProduct2</code>, rather than supporting explicit value unwrapping, <code>Either</code> supports many useful comprehensions to help facilitate type-safe interactions:    </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Either&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span> right <span class="pl-k">=</span> <span class="pl-smi">Either</span><span class="pl-k">.</span>right(<span class="pl-c1">1</span>);
<span class="pl-k">Either&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Integer</span>&gt;</span> left <span class="pl-k">=</span> <span class="pl-smi">Either</span><span class="pl-k">.</span>left(<span class="pl-s"><span class="pl-pds">"</span>Head fell off<span class="pl-pds">"</span></span>);

<span class="pl-smi">Integer</span> result <span class="pl-k">=</span> right<span class="pl-k">.</span>orElse(<span class="pl-k">-</span><span class="pl-c1">1</span>);
<span class="pl-c">//-&gt; 1</span>

<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span> values <span class="pl-k">=</span> left<span class="pl-k">.</span>match(l <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-smi">Collections</span><span class="pl-k">.</span>emptyList(), <span class="pl-smi">Collections</span><span class="pl-k">::</span>singletonList);
<span class="pl-c">//-&gt; [] </span></pre></div>

<p>Check out the tests for <a href="https://github.com/palatable/lambda/blob/master/src/test/java/com/jnape/palatable/lambda/adt/EitherTest.java">more examples</a> of ways to interact with <code>Either</code>.</p>

<h2>
<a id="lenses" class="anchor" href="#lenses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="lenses">Lenses</a>
</h2>

<p>Lambda also ships with a first-class <a href="https://www.youtube.com/watch?v=cefnmjtAolY&amp;feature=youtu.be&amp;hd=1">lens</a> type, as well as a small library of useful general lenses:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Lens&lt;<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>, <span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span>, <span class="pl-k">Optional&lt;<span class="pl-smi">String</span>&gt;</span>, <span class="pl-smi">String</span>&gt;</span> stringAt0 <span class="pl-k">=</span> <span class="pl-smi">ListLens</span><span class="pl-k">.</span>at(<span class="pl-c1">0</span>);

<span class="pl-k">List&lt;<span class="pl-smi">String</span>&gt;</span> strings <span class="pl-k">=</span> asList(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>);
view(stringAt0, strings); <span class="pl-c">// Optional[foo]</span>
set(stringAt0, <span class="pl-s"><span class="pl-pds">"</span>quux<span class="pl-pds">"</span></span>, strings); <span class="pl-c">// [quux, bar, baz]</span>
over(stringAt0, s <span class="pl-k">-</span><span class="pl-k">&gt;</span> s<span class="pl-k">.</span>map(<span class="pl-smi">String</span><span class="pl-k">::</span>toUpperCase)<span class="pl-k">.</span>orElse(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>), strings); <span class="pl-c">// [FOO, bar, baz]</span></pre></div>

<p>There are three functions that lambda provides that interface directly with lenses: <code>view</code>, <code>over</code>, and <code>set</code>. As the name implies, <code>view</code> and <code>set</code> are used to retrieve values and store values, respectively, whereas <code>over</code> is used to apply a function to the value a lens is focused on, alter it, and store it (you can think of <code>set</code> as a specialization of <code>over</code> using <code>constantly</code>).</p>

<p>Lenses can be easily created. Consider the following <code>Person</code> class:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-en">Person</span> {
    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-k">int</span> age;

    <span class="pl-k">public</span> <span class="pl-en">Person</span>(<span class="pl-k">int</span> <span class="pl-v">age</span>) {
        <span class="pl-v">this</span><span class="pl-k">.</span>age <span class="pl-k">=</span> age;
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getAge</span>() {
        <span class="pl-k">return</span> age;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Person</span> <span class="pl-en">setAge</span>(<span class="pl-k">int</span> <span class="pl-v">age</span>) {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Person</span>(age);
    }

    <span class="pl-k">public</span> <span class="pl-smi">Person</span> <span class="pl-en">setAge</span>(<span class="pl-smi">LocalDate</span> <span class="pl-v">dob</span>) {
        <span class="pl-k">return</span> setAge((<span class="pl-k">int</span>) <span class="pl-c1">YEARS</span><span class="pl-k">.</span>between(dob, <span class="pl-smi">LocalDate</span><span class="pl-k">.</span>now()));
    }
}</pre></div>

<p>...and a lens for getting and setting <code>age</code> as an <code>int</code>:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Lens&lt;<span class="pl-smi">Person</span>, <span class="pl-smi">Person</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">Integer</span>&gt;</span> ageLensWithInt <span class="pl-k">=</span> <span class="pl-smi">Lens</span><span class="pl-k">.</span>lens(<span class="pl-smi">Person</span><span class="pl-k">::</span>getAge, <span class="pl-smi">Person</span><span class="pl-k">::</span>setAge);

<span class="pl-c">//or, when each pair of type arguments match...</span>

<span class="pl-smi">Lens</span><span class="pl-k">.</span><span class="pl-k">Simple&lt;<span class="pl-smi">Person</span>, <span class="pl-smi">Integer</span>&gt;</span> alsoAgeLensWithInt <span class="pl-k">=</span> <span class="pl-smi">Lens</span><span class="pl-k">.</span>simpleLens(<span class="pl-smi">Person</span><span class="pl-k">::</span>getAge, <span class="pl-smi">Person</span><span class="pl-k">::</span>setAge);</pre></div>

<p>If we wanted a lens for the <code>LocalDate</code> version of <code>setAge</code>, we could use the same method references and only alter the type signature:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Lens&lt;<span class="pl-smi">Person</span>, <span class="pl-smi">Person</span>, <span class="pl-smi">Integer</span>, <span class="pl-smi">LocalDate</span>&gt;</span> ageLensWithLocalDate <span class="pl-k">=</span> <span class="pl-smi">Lens</span><span class="pl-k">.</span>lens(<span class="pl-smi">Person</span><span class="pl-k">::</span>getAge, <span class="pl-smi">Person</span><span class="pl-k">::</span>setAge);</pre></div>

<p>Compatible lenses can be trivially composed:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Lens&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-k">Optional&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-smi">Integer</span>&gt;</span> at0 <span class="pl-k">=</span> <span class="pl-smi">ListLens</span><span class="pl-k">.</span>at(<span class="pl-c1">0</span>);
<span class="pl-k">Lens&lt;<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> atFoo <span class="pl-k">=</span> <span class="pl-smi">MapLens</span><span class="pl-k">.</span>atKey(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, emptyList());

view(atFoo<span class="pl-k">.</span>andThen(at0), singletonMap(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, asList(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>))); <span class="pl-c">// Optional[1]</span></pre></div>

<p>Lens provides independent <code>map</code> operations for each parameter, so incompatible lenses can also be composed: </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">Lens&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-k">Optional&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-smi">Integer</span>&gt;</span> at0 <span class="pl-k">=</span> <span class="pl-smi">ListLens</span><span class="pl-k">.</span>at(<span class="pl-c1">0</span>);
<span class="pl-k">Lens&lt;<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">Optional&lt;<span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span> atFoo <span class="pl-k">=</span> <span class="pl-smi">MapLens</span><span class="pl-k">.</span>atKey(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>);
<span class="pl-k">Lens&lt;<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-k">List&lt;<span class="pl-smi">Integer</span>&gt;</span>&gt;</span>, <span class="pl-k">Optional&lt;<span class="pl-smi">Integer</span>&gt;</span>, <span class="pl-smi">Integer</span>&gt;</span> composed <span class="pl-k">=</span>
        atFoo<span class="pl-k">.</span>mapA(optL <span class="pl-k">-</span><span class="pl-k">&gt;</span> optL<span class="pl-k">.</span>orElse(singletonList(<span class="pl-k">-</span><span class="pl-c1">1</span>)))
                .andThen(at0);

view(composed, singletonMap(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, emptyList())); <span class="pl-c">// Optional.empty</span></pre></div>

<p>Check out the tests or the <a href="http://palatable.github.io/lambda/javadoc/">javadoc</a> for more info.</p>

<h2>
<a id="notes" class="anchor" href="#notes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="notes">Notes</a>
</h2>

<p>Wherever possible, <em>lambda</em> maintains interface compatibility with similar, familiar core Java types. Some examples of where this works well is with both <code>Fn1</code> and <code>Predicate</code>, which extend <code>j.u.f.Function</code> and <code>j.u.f.Predicate</code>, respectively. In these examples, they also override any implemented methods to return their <em>lambda</em>-specific counterparts (<code>Fn1.compose</code> returning <code>Fn1</code> instead of <code>j.u.f.Function</code> as an example).</p>

<p>Unfortunately, due to Java's type hierarchy and inheritance inconsistencies, this is not always possible. One surprising example of this is how <code>Fn1</code> extends <code>j.u.f.Function</code>, but <code>Fn2</code> does not extend <code>j.u.f.BiFunction</code>. This is because <code>j.u.f.BiFunction</code> itself does not extend <code>j.u.f.Function</code>, but it does define methods that collide with <code>j.u.f.Function</code>. For this reason, both <code>Fn1</code> and <code>Fn2</code> cannot extend their Java counterparts without sacrificing their own inheritance hierarchy. These types of asymmetries are, unfortunately, not uncommon; however, wherever these situations arise, measures are taken to attempt to ease the transition in and out of core Java types (in the case of <code>Fn2</code>, a supplemental <code>#toBiFunction</code> method is added). I do not take these inconveniences for granted, and I'm regularly looking for ways to minimize the negative impact of this as much as possible. Suggestions and use cases that highlight particular pain points here are particularly appreciated.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a name="license">License</a>
</h2>

<p><em>lambda</em> is part of <a href="http://www.github.com/palatable">palatable</a>, which is distributed under <a href="http://choosealicense.com/licenses/mit/">The MIT License</a>.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
